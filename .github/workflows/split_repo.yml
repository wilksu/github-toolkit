# .github/workflows/split_repo_from_url.yml

name: Split Subdirectory From URL (V3)

on:
  workflow_dispatch:
    inputs:
      source_dir_url:
        description: '要拆分的源目录的完整 URL'
        required: true
      new_repo_name:
        description: '新仓库的名称 (e.g., luci-app-zerotier-standalone)'
        required: true
      # 新增：仓库可见性选项
      visibility:
        description: '新仓库的可见性 (public 或 private)'
        type: choice
        options: ['private', 'public']
        default: 'private'
        required: true
      # 新增：分支处理选项
      branch_behavior:
        description: "分支处理方式: 'single' (仅保留链接中的分支) 或 'all' (保留所有分支)"
        type: choice
        options: ['single', 'all']
        default: 'single'
        required: true

jobs:
  split-repository:
    runs-on: ubuntu-latest
    steps:
      - name: 1. Parse Input URL
        id: parser
        run: |
          URL="${{ inputs.source_dir_url }}"
          # 脚本现在也会解析分支名
          NO_PROTO_URL=$(echo "$URL" | sed -e 's;https://github.com/;;')
          OWNER_REPO=$(echo "$NO_PROTO_URL" | cut -d'/' -f1-2)
          BRANCH_NAME=$(echo "$NO_PROTO_URL" | cut -d'/' -f4)
          REPO_URL="https://github.com/$OWNER_REPO"
          SUBDIR_PATH=$(echo "$NO_PROTO_URL" | sed -e "s;$OWNER_REPO/tree/[^/]\+/;;")
          
          # 设置输出
          echo "REPO_URL=$REPO_URL" >> $GITHUB_OUTPUT
          echo "SUBDIR_PATH=$SUBDIR_PATH" >> $GITHUB_OUTPUT
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "Parsed Branch: $BRANCH_NAME"

      - name: 2. Set up Python and install git-filter-repo
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      - run: pip install git-filter-repo

      - name: 3. Create New Repository
        run: |
          # 根据输入动态设置 --public 或 --private
          gh repo create ${{ github.repository_owner }}/${{ inputs.new_repo_name }} --${{ inputs.visibility }} -d "Split from ${{ steps.parser.outputs.SUBDIR_PATH }} of ${{ steps.parser.outputs.REPO_URL }}"
        env:
          GITHUB_TOKEN: ${{ secrets.ACTION_PAT }}
      
      - name: 4. Clone source repository
        run: git clone --mirror ${{ steps.parser.outputs.REPO_URL }} source-mirror

      - name: 5. Filter the subdirectory
        run: |
          cd source-mirror
          git-filter-repo --path ${{ steps.parser.outputs.SUBDIR_PATH }}
      
      - name: 6. Push to new repository
        run: |
          cd source-mirror
          git remote add new_origin "https://x-access-token:${{ secrets.ACTION_PAT }}@github.com/${{ github.repository_owner }}/${{ inputs.new_repo_name }}.git"
          
          # 根据用户选择的分支行为来决定如何推送
          if [ "${{ inputs.branch_behavior }}" == "single" ]; then
            echo "Pushing single branch mode: Pushing '${{ steps.parser.outputs.BRANCH_NAME }}' as 'main' branch."
            # 强制将解析出的分支作为新仓库的 main 分支进行推送
            git push --force new_origin ${{ steps.parser.outputs.BRANCH_NAME }}:main
          else
            echo "Pushing all branches mode."
            git push --all new_origin
          fi
          
          # 无论哪种模式，都推送所有标签
          echo "Pushing all tags."
          git push --tags new_origin
      
      - name: 7. Print new repository URL
        run: |
          echo "✅ New repository created successfully!"
          echo "Access it here: https://github.com/${{ github.repository_owner }}/${{ inputs.new_repo_name }}"